The following paragraphs describe 'InK', an API and runtime framework. Later on, you will use this description of InK to transform C code into InK-compliant code. So remember the following description for later.
'InK' is a runtime and API meant for programming task-based intermittent computers. Intermittent computers sometimes run out of power and shut down. InK allows the computer to continue where it shut off, by periodically backing up the state of the computer into Non-Volatile Memory (NVM). NVM does not lose data when powered off, which allows the state of the computer to be saved until the next power on.
In order to periodically back up the state, the InK runtime needs to know when this can be done. To make this clear, the program is split into tasks by the programmer. These tasks take the form of C functions. Each task does computations as described inside the function body, and then returns a pointer to the next task to be executed. If there is no next task, the return pointer is NULL. After a task is done executing, InK will back up the system state. The InK runtime will then select the next task to execute.
The system state is represented by some global variables in C. These variables are shared between tasks within a thread. When a variable is part of the system state, it is called a `task-shared` variable. The task-shared variables can only be used inside tasks; using them outside tasks is illegal.
A unique thing about InK is that it uses threads, which are distinct from tasks. Each thread contains multiple tasks, and there can be a maximum of 64 threads in a program. Threads are explicitly created by the programmer using an API call (described below). A thread can be either 'active' or 'dormant'. If a thread is active, its tasks can be executed by the InK runtime. If a thread is dormant, the InK runtime needs to wait for an event. Events are signalled by the programmer inside interrupts and are stored internally inside a persistent queue. There is one queue for every thread. If the event is triggered, the thread goes from the 'dormant' state to the 'active' state; the thread is 'activated'. When this thread is selected, the event that triggered the state change is passed to the first task in the thread; this task is called the 'entry task'. By default, a thread is in the 'dormant' state on creation.
The InK runtime uses priority scheduling to select which thread to execute. As such, each thread has a specified priority, which is a number from 1 up to and including 64. Different threads cannot have the same priority. This limits the maximum number of threads to 64.
To facilitate the backing up of state into NVM in this task-based programming environment, the InK runtime requires hints from the programmer. These hints take the form of API functions. The following bullet list describes the API functions and instructions on where and when to use them.
- API functions for interfacing. When the system boots up for the first time, threads need to be created. To facilitate this creation, the InK runtime calls the `void __app_init()` function on first boot. This function must be defined by the programmer. There is also the `void __app_reboot()` function, which is called when the system reboots. This can be used to specify actions that need to happen at every reboot.
- API functions for creating threads. The `__CREATE(prio, entry_task)` function creates a thread. The `prio` argument is a number that represents the priority of the thread. The `entry_task` argument is a pointer to the function that is the entry task of the thread to be created. The `__CREATE(prio, entry_task)` function should always and only be called when the system boots for the first time. For example, if we want to create a thread with priority `15` and entry task function `t_init`, we call `__CREATE(15, t_init)`.
- API functions for activating threads. To activate a thread, one can use the `__SIGNAL(prio)` function. The `prio` argument is a number that represents the priority of the thread to activate. For example, if we want to activate the thread with priority `15`, we call `__SIGNAL(15)`.
- API functions for specifying tasks. To specify that a function is an InK task, the entire function signature should be replaced by `TASK(<func_name>)`, where `<func_name>` is the name of the original function. This should be done for both the function declaration and function definition. The entry task for a thread should use `ENTRY_TASK` instead of `TASK`. For example, if we want to convert the function declaration `void* some_func()` to a task, we replace it with `TASK(some_func)`.
- API functions for specifying when a global variable is task-shared. The `__shared(...)` macro. This macro should be called in the global scope, before any function definition or declaration. The `...` in this macro is to be replaced a ';' delimited list of variable declarations for task-shared variables. Variable definitions are not allowed. The `__shared(...)` macro will mark these variables as task-shared. NOTE: there must be at least 2 bytes of data inside the `__shared(...)` macro, otherwise there will be a compiler error.
- API functions for specifying when a task-shared variable is read. Every time a task-shared variable is read inside a task function, the name of that variable should be replaced by `__GET(<var_name>)`, where `<var_name>` is the name of the variable to be replaced.
- API functions for specifying when a task-shared variable is written. Every time a task-shared variable is written inside a task function, the assignment expression should be replaced by `__SET(<var_name>, <value>)`, where `<var_name>` is the name of the variable, and `<value>` is the value that is written to the variable.
- API functions for events. To check if the event queue is full, the programmer can use `__EVENT_BUFFER_FULL(prio)`, where the `prio` parameter corresponds to the priority of the thread that we want to check the event queue for. To signal an event, the programmer can use `__SIGNAL_EVENT(prio, event)`. This function should only be called inside interrupt service routines! The `prio` parameter is the priority of the thread that the programmer wants to activate using the event. The `event` parameter is a pointer to the event of type `isr_event_t`, used to activate the thread. The struct `isr_event_t` has the following instance variables: 1) `void *data`, a pointer to the data associated with the event. This data should be allocated inside NVM to make sure it is persistent across power failures; 2) `uint32_t size`, the size of the data buffer in bytes; 3) `uint32_t timestamp`, timestamp at which the event took place. Since we do not use the timer functionality of InK, this remains unused and can be set to 0. When a thread is activated by an event, the pointer to that event can be accessed using the `__event` variable. This variable can only be accessed inside the entry task!
- API for setting a variable as persistent non-task shared. If the programmer wants to have a variable that is stored in NVM, but is not supposed to be task-shared, they can use the `__nv` macro. This macro is to be placed in front of the variable declaration.

The API header file is ‘ink.h’.
