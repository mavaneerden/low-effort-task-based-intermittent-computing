The following paragraphs describe 'CITID', an API and runtime framework. Later on, you will use this description of CITID to transform C code into CITID-compliant code. So remember the following description for later.
'CITID' is a runtime and API meant for programming task-based intermittent computers. Intermittent computers sometimes run out of power and shut down. CITID allows the computer to continue where it shut off, by periodically backing up the state of the computer into Non-Volatile Memory (NVM). NVM does not lose data when powered off, which allows the state of the computer to be saved until the next power on.
In order to periodically back up the state, the CITID runtime needs to know when this can be done. To make this clear, the program is split into tasks by the programmer. These tasks take the form of C functions. Each task does computations as described inside the function body, and then returns a pointer to the next task to be executed. If there is no next task, the return pointer is NULL. After a task is done executing, CITID will back up the system state. The CITID runtime will then select the next task to execute.
The system state is represented by some global variables in C. These variables are shared between tasks within a thread. When a variable is part of the system state, it is called a `task-shared` variable. The task-shared variables can only be used inside tasks; using them outside tasks is illegal.
A unique thing about CITID is that it uses threads, which are distinct from tasks. Each thread contains multiple tasks, and there can be a maximum of 64 threads in a program. Threads are explicitly created by the programmer using an API call (described below). A thread can be either 'active' or 'dormant'. If a thread is active, its tasks can be executed by the CITID runtime. If a thread is dormant, the CITID runtime needs to wait for an event. Events are signalled by the programmer inside interrupts and are stored internally inside a persistent queue. There is one queue for every thread. If the event is triggered, the thread goes from the 'dormant' state to the 'active' state; the thread is 'activated'. When this thread is selected, the event that triggered the state change is passed to the first task in the thread; this task is called the 'entry task'.
The CITID runtime uses priority scheduling to select which thread to execute. As such, each thread has a specified priority, which is a number from 1 up to and including 64. Different threads cannot have the same priority. This limits the maximum number of threads to 64.
Next to the CITID runtime, there is the CITID compiler. Task-shared variables are detected automatically by the compiler, by checking if a variable with global storage is used inside one or more task functions. If it is, it is marked as task-shared; no instrumentation is required by the programmer. If the variable does not have global storage, or is not used inside any task function, it is ignored by the CITID compiler, and marked as non-task-shared and not in NVM.
To facilitate the backing up of state into NVM in this task-based programming environment, the CITID runtime requires hints from the programmer. These hints take the form of API functions. The following bullet list describes the API functions and instructions on where and when to use them.
- API functions for interfacing. After system initialisation, the CITID runtime needs to be called using the `citid_scheduler_run()` function. This can be done in the `main` function of the program.
- API functions for creating threads. A thread can be created using the `CITID_CREATE_THREAD(prio, activate_on_first_boot)` macro. The `prio` parameter is a number representing the priority of the thread. The `activate_on_first_boot` parameter is a boolean value. If set to true, the created thread is activated on first boot. If false, the created thread remains dormant until woken up by an event.
  In addition, the `CITID_CREATE_THREAD` macro defines the thread's entry task.
  The function pointer to the entry task created by the `CITID_CREATE_THREAD` macro can be accessed using the `CITID_THREAD_ENTRY_TASK` macro. The `CITID_THREAD_ENTRY_TASK` macro takes no arguments; the thread priority is automatically deduced.
- API functions for directing the compiler. To explicitly exclude a variable from being flagged as task-shared by the compiler, you can place the `CITID_IGNORE` macro before the variable definition. This also does not store the variable into NVM. To exclude variables from being flagged as task-shared by the compiler, **but** still store them in NVM, you can place the `CITID_PERSISTENT` macro before the variable definition. The `CITID_IGNORE` and `CITID_PERSISTENT` macro's override the default compiler behaviour.
- API functions for events. To signal an event, the programmer can use `citid_signal_event_isr(prio, event)`. This function should only be called inside interrupt service routines! The `prio` parameter is the priority of the thread that the programmer wants to activate using the event. The `event` parameter is a pointer to the event of type `citid_event_t`, used to activate the thread. The struct `citid_event_t` has the following instance variables: 1) `void *data`, a pointer to the data associated with the event. This data should be allocated inside NVM to make sure it is persistent across power failures; 2) `uint32_t size`, the size of the data buffer in bytes; 3) `uint32_t timestamp`, timestamp at which the event took place. Since we do not use the timer functionality of InK, this remains unused and can be set to 0. When a thread is activated by an event, the pointer to that event can be accessed using the `citid_event` variable. This variable can only be accessed inside the entry task!
- API functions for activating threads. To activate a thread from another thread, the programmer can call the `citid_activate_thread(prio)` function. Here, `prio` is a number representing the priority of the thread we want to activate.

The API header file is ‘citid.h’.