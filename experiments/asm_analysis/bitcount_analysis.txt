Setting a variable in the persistent struct:

NEW:
    # Before this, the current index is stored in r10.
    # Move the current index into r12.
    53ca:	0c 4a       	mov	r10,	r12	;

    # Move 22 (the size of one struct in bytes) to r13
    53cc:	7d 40 16 00 	mov.b	#22,	r13	;#0x0016

    # Call to hardware multiplier: r12 = r12 * r13
    # The MSP430 compiler calculates the offset by multiplying.
    # This is inefficient because the index can only be 1 or 0, but the compiler doesn't know this.
    53d0:	b0 12 d0 71 	call	#29136		;#0x71d0

    # Put the address of the persistent variable in r12.
    53d4:	1c 4c 10 45 	mov	17680(r12),r12	;0x04510

    # Set variable.
    53d8:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

LEGACY
    # Before this, the entire address is saved in r12.
    mov.b	#1,	0(r12)	;r3 As==01


Verdict:
    The compiler is stupid. It does the exact same calculations for every single variable access.
    The only thing that changes is the address offset. As such, every access could be done with 2 instructions
    (get address, store value) instead of 5 + 7(hw mult) = 12.
    -O3 actually does this, but -Os does not.
